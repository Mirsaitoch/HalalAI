"""Расширение и нормализация запросов для улучшения RAG поиска."""

import re
from typing import Dict, List


# Расширенный словарь синонимов для исламских терминов (ключи - корни слов)
# Организован по категориям для лучшей поддержки
QUERY_SYNONYMS: Dict[str, List[str]] = {
    # === Еда и напитки ===
    "свинин": ["мясо свиньи", "свиное мясо", "свинья", "хинзир"],
    "алкоголь": ["хамр", "спиртное", "вино", "опьяняющие напитки", "хмельное"],
    "мясо": ["дичь", "забой", "халяльное мясо", "закланное"],
    "кровь": ["кровяной", "кровавый"],
    "мертвечин": ["падаль", "умершее животное", "мертвое"],
    
    # === Молитва и поклонение ===
    "намаз": ["молитва", "салят", "салат", "صلاة"],
    "дуа": ["молитва", "просьба к аллаху", "мольба", "دعاء"],
    "вуду": ["омовение", "тахарат", "очищение"],
    "такбир": ["аллаху акбар", "возвеличивание"],
    "руку": ["поясной поклон", "наклон"],
    "саджда": ["земной поклон", "суджуд", "سجدة"],
    
    # === Пост ===
    "пост": ["ураза", "рамадан", "саум", "صوم"],
    "ифтар": ["разговение", "прекращение поста", "вечерний прием пищи"],
    "сухур": ["предрассветная еда", "сахур", "سحور"],
    "рамадан": ["священный месяц", "месяц поста", "رمضان"],
    
    # === Закят и милостыня ===
    "закят": ["милостыня", "обязательная милостыня", "زكاة", "налог"],
    "садака": ["добровольная милостыня", "صدقة", "пожертвование"],
    "фитр": ["милостыня разговения", "закят аль-фитр"],
    
    # === Паломничество ===
    "хадж": ["паломничество", "мекка", "حج", "большое паломничество"],
    "умра": ["малое паломничество", "عمرة", "малый хадж"],
    "кааба": ["священная кааба", "الكعبة", "дом аллаха"],
    "сафа": ["холм сафа", "الصفا"],
    "марва": ["холм марва", "المروة"],
    "арафат": ["гора арафат", "عرفات"],
    "мина": ["долина мина", "منى"],
    
    # === Правовые категории ===
    "харам": ["запрещено", "запретно", "грех", "حرام", "недозволено"],
    "халяль": ["дозволено", "разрешено", "позволено", "حلال", "законно"],
    "макрух": ["нежелательно", "مكروه", "порицаемо"],
    "мустахаб": ["желательно", "рекомендуемо", "مستحب", "похвально"],
    "фард": ["обязательно", "فرض", "обязанность"],
    "ваджиб": ["необходимо", "واجب", "долг"],
    "мубах": ["дозволено", "مباح", "нейтрально"],
    
    # === Коран и Сунна ===
    "коран": ["священный коран", "писание", "القرآن", "божественное откровение"],
    "сура": ["глава корана", "سورة"],
    "аят": ["стих корана", "آية", "знамение"],
    "хадис": ["предание", "сунна", "حديث", "изречение пророка"],
    "сунна": ["путь пророка", "سنة", "традиция"],
    "таfsир": ["толкование", "تفسير", "комментарий"],
    
    # === Вера и убеждения ===
    "иман": ["вера", "إيمان", "убеждение"],
    "такуа": ["богобоязненность", "تقوى", "благочестие"],
    "ширк": ["многобожие", "شرك", "придание сотоварищей"],
    "куфр": ["неверие", "كفر", "отрицание"],
    "таухид": ["единобожие", "توحيد", "вера в единство"],
    "ислам": ["покорность", "إسلام", "предание себя аллаху"],
    
    # === Социальные отношения ===
    "никах": ["брак", "نكاح", "бракосочетание"],
    "талак": ["развод", "طلاق", "расторжение брака"],
    "махр": ["брачный дар", "مهر", "выкуп"],
    "хиджаб": ["покрывало", "حجاب", "платок", "скромная одежда"],
    "аурат": ["عورة", "то что следует покрывать"],
    
    # === Временные понятия ===
    "джума": ["пятница", "جمعة", "пятничная молитва"],
    "ид": ["праздник", "عيد", "курбан", "фитр"],
    "лейла": ["ночь", "ليلة"],
    "кадр": ["ночь предопределения", "лейлятуль-кадр"],
}


def generate_query_variants(query: str, max_variants: int = 5) -> List[str]:
    """
    Генерирует множественные варианты запроса для улучшения RAG поиска.
    
    Комбинирует нормализацию, расширение синонимами и контекстные ключевые слова.
    
    Args:
        query: Оригинальный запрос пользователя
        max_variants: Максимальное количество вариантов (по умолчанию 5)
        
    Returns:
        Список вариантов запроса (от наиболее до наименее релевантных)
    """
    variants = []
    
    # 1. Нормализованный запрос (самый важный)
    normalized = normalize_food_query(query)
    variants.append(normalized)
    
    # 2. Варианты с синонимами
    expanded = expand_query(query)
    for variant in expanded:
        if variant not in variants:
            variants.append(variant)
    
    # 3. Добавляем контекстные ключевые слова
    context_keywords = get_context_keywords(query)
    if context_keywords and normalized not in variants:
        enhanced = normalized + " " + " ".join(context_keywords)
        if enhanced not in variants:
            variants.append(enhanced)
    
    # 4. Оригинальный запрос (на случай если нормализация ухудшила)
    if query not in variants:
        variants.append(query)
    
    # Ограничиваем до max_variants самых важных вариантов
    return variants[:max_variants]


def expand_query(query: str) -> List[str]:
    """
    Расширяет запрос синонимами для улучшения поиска.
    
    Args:
        query: Оригинальный запрос пользователя
        
    Returns:
        Список вариантов запроса включая оригинал
    """
    query_lower = query.lower()
    variants = [query]  # Начинаем с оригинала
    
    # Ищем известные термины в запросе (с учетом разных форм слова)
    for term, synonyms in QUERY_SYNONYMS.items():
        # Ищем по корню слова (например "свинин" найдет "свинину", "свинины" и т.д.)
        # Используем [а-яёА-ЯЁ]* для кириллицы и убираем \b в конце
        term_pattern = rf'\b{re.escape(term)}[а-яёА-ЯЁ]*'
        if re.search(term_pattern, query_lower):
            # Создаем варианты с каждым синонимом
            for synonym in synonyms:
                # Заменяем термин на синоним
                variant = re.sub(
                    term_pattern,
                    synonym,
                    query_lower,
                    flags=re.IGNORECASE
                )
                if variant != query_lower and variant not in variants:
                    variants.append(variant)
    
    return variants[:5]  # Ограничиваем 5 вариантами


def normalize_food_query(query: str) -> str:
    """
    Нормализует запросы о еде для лучшего поиска в Коране.
    
    Args:
        query: Запрос пользователя
        
    Returns:
        Нормализованный запрос
    """
    query_lower = query.lower()
    
    # Заменяем "свинина" на "мясо свиньи" (как в Коране)
    if "свинин" in query_lower:
        query_lower = re.sub(r'\bсвинин\w*\b', 'мясо свиньи', query_lower)
    
    # Для вопросов о свинине добавляем ключевые слова из аятов
    if "свин" in query_lower:
        keywords_to_add = []
        
        # Если это вопрос "что говорится", "можно ли" и т.д.
        if any(word in query_lower for word in ["что", "говор", "можно", "ли", "разрешен", "дозволен"]):
            keywords_to_add.extend([
                "запрет", "запретил", "харам",
                "мертвечина", "кровь", "принесено жертву"
            ])
        
        if keywords_to_add:
            query_lower += " " + " ".join(keywords_to_add)
    
    # Расширяем для других категорий еды
    if "алкоголь" in query_lower or "вино" in query_lower:
        if any(word in query_lower for word in ["можно", "ли", "разрешен", "дозволен"]):
            query_lower += " хамр запрет опьяняющий"
    
    return query_lower


def get_query_category(query: str) -> str:
    """
    Определяет категорию запроса для оптимизации поиска.
    
    Приоритет: более специфичные категории проверяются первыми.
    
    Args:
        query: Запрос пользователя
        
    Returns:
        Название категории или 'general'
    """
    query_lower = query.lower()
    
    # Категории с ключевыми словами (порядок важен - от специфичных к общим)
    categories = [
        ("food", ["свинин", "мясо", "еда", "пища", "алкоголь", "вино", "кровь", "есть"]),
        ("prayer", ["намаз", "молитва", "салят", "дуа", "вуду", "омовение"]),
        ("fasting", ["пост", "ураза", "рамадан", "ифтар", "сухур"]),
        ("charity", ["закят", "садака", "милостын"]),
        ("pilgrimage", ["хадж", "умра", "кааба", "мекка", "паломничеств"]),
        ("law", ["харам", "халяль", "дозволен", "запрещен", "макрух", "мустахаб"]),
        ("faith", ["иман", "вера", "таухид", "ширк"]),
    ]
    
    for category, keywords in categories:
        if any(keyword in query_lower for keyword in keywords):
            return category
    
    return "general"


def get_rag_relevance_keywords(query: str) -> List[str]:
    """
    Возвращает ключевые подстроки, по которым можно проверить релевантность чанка.

    Если в тексте чанка есть хотя бы одна из этих подстрок, он считается тематически
    релевантным запросу (например, про свинину — в чанке должно быть «свинин» или «мясо свиньи»).

    Используется для переранжирования результатов RAG: сначала возвращаем чанки с совпадением.

    Args:
        query: Поисковый запрос пользователя

    Returns:
        Список подстрок для проверки (в нижнем регистре), без дубликатов
    """
    query_lower = query.lower()
    keywords = []

    # По словарю синонимов: если в запросе есть термин — добавляем корень и короткие синонимы
    for term, synonyms in QUERY_SYNONYMS.items():
        term_pattern = rf'\b{re.escape(term)}[а-яё]*'
        if re.search(term_pattern, query_lower):
            keywords.append(term)
            # Добавляем синонимы только из кириллицы/латиницы (для поиска в русском тексте)
            for syn in synonyms:
                syn_clean = "".join(
                    c for c in syn
                    if c.isalpha() and (ord(c) < 0x0600 or ord(c) > 0x06FF) or c.isspace()
                ).strip()
                if syn_clean and len(syn_clean) >= 2 and syn_clean.lower() not in [k.lower() for k in keywords]:
                    keywords.append(syn_clean.lower())
            # Ограничиваем количество синонимов на один термин
            if len(keywords) > 15:
                break

    # Уникальные, в нижнем регистре, длинные фразы разбиваем на отдельные слова для поиска
    seen = set()
    result = []
    for k in keywords:
        k_lower = k.lower()
        if k_lower in seen or len(k_lower) < 2:
            continue
        seen.add(k_lower)
        result.append(k_lower)
        # Для фраз типа "мясо свиньи" добавляем и отдельные значимые слова
        if " " in k_lower:
            for w in k_lower.split():
                if len(w) >= 3 and w not in seen:
                    seen.add(w)
                    result.append(w)

    return result[:20]  # Не более 20 ключей


def decompose_complex_query(query: str) -> List[str]:
    """
    Разбивает сложный вопрос на подвопросы для лучшего поиска.
    
    Например:
    "Что говорится о свинине и алкоголе?" -> ["Что говорится о свинине?", "Что говорится об алкоголе?"]
    
    Args:
        query: Сложный запрос пользователя
        
    Returns:
        Список простых запросов (или исходный, если разбить не удалось)
    """
    query_lower = query.lower().strip()
    
    # Паттерны для разбиения
    if " и " not in query_lower:
        return [query]
    
    # Пытаемся найти конструкцию "X и Y"
    parts = query_lower.split(" и ", 1)  # Разбиваем только по первому " и "
    
    if len(parts) != 2:
        return [query]
    
    first_part = parts[0].strip()
    second_part = parts[1].strip()
    
    # Удаляем знаки препинания с конца второй части
    second_part = second_part.rstrip("?!.,;:")
    
    # Пытаемся извлечь базовый шаблон вопроса
    question_patterns = [
        (r'(что\s+говорится\s+о)\s+\S+', r'\1'),  # "что говорится о X"
        (r'(можно\s+ли)\s+\S+', r'\1'),  # "можно ли X"
        (r'(что\s+такое)\s+\S+', r'\1'),  # "что такое X"
        (r'(как\s+\S+)\s+\S+', r'\1'),  # "как X Y"
        (r'(когда\s+\S+)\s+\S+', r'\1'),  # "когда X Y"
    ]
    
    for pattern, replacement in question_patterns:
        match = re.match(pattern, first_part, re.IGNORECASE)
        if match:
            base_question = match.group(1)
            # Создаем два отдельных вопроса
            return [
                first_part.capitalize() + "?",
                (base_question + " " + second_part).capitalize() + "?"
            ]
    
    # Если паттерн не найден, пробуем простое разбиение
    # Ищем предлог "о", "про" и т.д.
    prep_match = re.search(r'\b(о|про|об)\s+(\S+)\s+и\s+(\S+)', query_lower)
    if prep_match:
        prep = prep_match.group(1)
        first_noun = prep_match.group(2)
        second_noun = prep_match.group(3).rstrip("?!.,;:")
        
        # Пытаемся воссоздать структуру вопроса
        prefix = query_lower[:prep_match.start()].strip()
        
        if prefix:
            return [
                f"{prefix} {prep} {first_noun}?".capitalize(),
                f"{prefix} {prep} {second_noun}?".capitalize()
            ]
    
    return [query]


def get_context_keywords(query: str) -> List[str]:
    """
    Извлекает контекстные ключевые слова на основе категории запроса.
    
    Args:
        query: Запрос пользователя
        
    Returns:
        Список контекстных ключевых слов для улучшения поиска
    """
    category = get_query_category(query)
    query_lower = query.lower()
    
    context_keywords = []
    
    # Добавляем контекстные слова в зависимости от категории
    if category == "food":
        context_keywords.extend(["дозволено", "запрещено", "халяль", "харам"])
    
    elif category == "prayer":
        context_keywords.extend(["обязательно", "время", "условия"])
    
    elif category == "fasting":
        context_keywords.extend(["обязательно", "нарушает", "дозволено"])
    
    elif category == "charity":
        context_keywords.extend(["обязательно", "размер", "кому"])
    
    elif category == "law":
        # Уже содержит нужные термины
        pass
    
    # Фильтруем слова, которых еще нет в запросе
    filtered_keywords = [kw for kw in context_keywords if kw not in query_lower]
    
    return filtered_keywords[:3]  # Ограничиваем 3 ключевыми словами
